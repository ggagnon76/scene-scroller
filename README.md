# scene-scroller
Fluidly stitch smaller segments of a scene together to simulate a much larger scene.

# Disclaimer
For anyone reading this document, please understand it is written as a brainstorming/design document so I can hammer out the features and solutions by writing them out.  For my own convenience, I will try to define all the design elements that I mention in this document, however there may be some that I overlooked that can leave you, a person unfamiliar with this project, confused or unable to fully understand what is being discussed.  That being said, the first couple sections are as much for you, as they are for me.  But once I get to the nitty gritty details, it'll resemble more a design document than anything else.

# Inspiration
I was DM'ing the Out of the Abyss module and in it, there is a chapter called 'The Labyrinth'.  I intended to produce map 'squares' that could be used to assemble a labyrinth on the fly via a module.  I envisioned having each map square populated with informative tags which would be used to filter incompatible squares, leaving a list of squares from which the module could randomly choose from to generate the labyrinth.  
My players would be rolling survival checks to make their way through the labyrinth, and if they failed more than they succeeded, I intended the module to spit them out of the labyrinth at designated 'encounters', one of which is the labyrinth entrance itself.  Each time they failed their survival checks, I (as the DM) would randomly roll for an encounter to resolve, then reduce the survival DC for the next round of checks.
To sum up, I wanted to be able to generate a labyrinth that the players would not be able to navigate as the player, having to rely on their character's skills instead. Foundry would, via my module, produce a truly maze-like maze that the player behind the character could not hope to figure out. 

While brainstorming and researching existing modules for inspiration or for an already made solution, I came across Zeel's Scene-Tiler module.  Their module allowed scenes in the Scene folder or in a compendium, to be dragged or programatically imported into the canvas as tiles.  The importing automatically created all the placeable objects along with it. And it also allowed for those tiles and associated placeables to be easily deleted!
This was a huge motivator to undertake my idea, as half the work was already done and available as a module I could simply include as a dependency.  I spent several months (I don't get to spend many hours per day, let alone every day to this hobby) to produce a proof of concept, which I called 'scene-zoetrope'.  That module was successfully completed and it did what I set out to prove, but it suffered from a couple issues:
1) I started coding scene-zoetrope at the end of Foundry V7 and finished it just before Foundry V9 was released.  Scene-zoetrope suffered from a bug that I thought was related to an existing bug report.  I thought when V9 would be released, the issue would be resolved.  I added work-arounds (adding delays in the code to give race conditions time to resolve) which worked well enough to see scene-zoetrope work in principle from the DM point of view.  Every time I fixed the client side code, I broke the DM side code and vice versa. 
2) The framework I implemented was based on fixed size map squares in a 3x3 grid.  Wonderful for a labyrinth whose design description stated there were no stretches longer than 10 feet before encountering another turn, either left or right, or up or down.  I wrote code that moved the Scene-Tiler tiles across this 3x3 grid and if they fell off the grid, I deleted the tile(s).  All nice and performant, excpet when I tried to make map squares for the concept, I found it really difficult to make the maps!  And mostly, my imagined method of breaking up existing maps was beyond difficult to the point of being impractical.  No content creators make maps that are neatly symmetric across a 3x3 grid!

The whole time I coded scene-zoetrope, I kept coming up with new ideas or solutions for the above (and other) gripes, but supressed them to avoid feature creep.  To sum up here, I ran into a lot of issues that were related to the restrictive framework I devised, I strugged with a particularly annoying bug and I kept having all these ideas for a more flexible implementation of my labyrinth module.  So when scene-zoetrope accomplished what it was meant to accomplish, I made a little video to show it off, called it a day and archived it.

P.S.  Sadly, my ability to produce the module did not keep pace with my player's progress in the game.  I ended up having to 'Theater of the Mind' much of the navigation in The Labyrinth and drop non-labyrinth like maps to resolve the combats.  My players never knew about the efforts I undertook that they never got to see, so they still enjoyed the sessions regardless.  I was very disappointed that I didn't implenent what my mind's eye could visualize in time, but it was extremely liberating to not have to continue devoloping a module I was no longer invested in.

# New module: Scene-Scroller
Being able to start from scratch and remove the restrictions I self inflicted on myself with scene-zoetrope, I imagined a much more useful implementation that is a re-imagining of Foundry core's concepts for maps.  But first...

**_What's with the name?_**  In my mind's eye, I imagine Scene-Scroller to work like old 2D games where the background scrolls from one side to the other, continously.  No loading screens, no map edges.  Just freedom to keep going in any direction.
Another way to describe this is: I imagine the active scene in Foundry to be a viewport looking at a small part of a much bigger map.  That bigger map is made up of small chunks of map of any size, which are stored in compendiums.  These chunks of maps have embedded information in them that tells the module how to stitch them together with another chunk of map. 

Back to Foundry's core concepts...  The underlying core mechanics assumes that the scene viewport is fixed and sized to the map.  Moving from one map to another results in a reload of the canvas scene containing a new map background, new placeables, etc...  Before V8, it was not possible to have 1 combat across 2 scenes.  In V8 it became possible, but wasn't really implemented by core and would still require the DM to juggle multiple scenes.  All tokens and placeables locations are saved using a coordinate system related to the map edges and all movement, vision, fog of war is relative to the map.

My vision for Scene-Scroller turns all that on it's head, so it is not a minor undertaking.  The brief breakdown follows:
1) The map pieces with all their placeables are imported as tiles.  The location of the tiles can dynamically move across the active scene viewport.
2) The active scene viewport can dynamically change size depending on how big it needs to be to fit the stitched together map pieces that any given token can see.
3) Everything is saved (on the server) at a fixed location, probably the top left corner at grid square 1x1.  This is a constant that will hopefuly make much of the underlying logic simpler.
4) Tiles, tokens and placeables all get rearranged to be in their proper position within the active scene viewport, locally on each client.  Each piece has flags that informs the module where it needs to be if it is to be active.  None of this is saved (on the server).
5) Any tiles, tokens and placeables that are not visible to the active token are suppressed (walls are filtered out of the vision calculations) and all other placeables, including the Scene-Tiler tiles, have their visibility set to False.  This will hopefully make large 'intense/complex' scenes possible for users that have potato computers.
6) Each user (with their token) can head off in different directions and be seeing/rendering different things on their local computers.  Combat can occur in multiple areas, but still all in one active scene with one combat tracker!
7) The DM will be able to see what any given token sees by clicking on that token, at which point the tiles will re-arrange themselves to show what the token is supposed to be seeing.
