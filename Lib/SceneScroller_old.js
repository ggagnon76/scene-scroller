 import { ModuleName } from "../ss-initialize.js";
import { ScrollerInitiateScene, ScrollerViewSubSceneSelector } from "./Forms.js";
import { socketWrapper, msgDict } from "./Socket.js";
import { createTilerTile, isVisiblePlaceables, log, moveTokensLocal, resetMainScene, tilerTilePlaceables } from "./Functions.js";

/**
 * Manipulates a scene in several ways to stitch smaller scenes together to simulate a much bigger scene
 * 
 * UPDATE: This was originially defined as a class, so it could be extended in the future to implement a random function to
 *         generate mazes from random map pieces.
 * 
 * This class is expected to manipulate the scene in several ways:
 *  - Change the size of the scene on the fly, to accomododate new sub-scenes
 *  - Move the contents (placeables) in the sub-scene based on what viewpoint (token or sub-scene) is selected to be viewed.
 * 
 * @class SceneScroller
 */
export class SceneScroller {

    /**
     * A schema of the flag data that is stored in the VIEWPORT.
     * @memberof SceneScroller
     * 
     * NOTE: sceneScrollerSceneFlags is just a variable to access the object.  Accessing the object key/value has to be done
     *       directly in the flags.  For example: canvas.scene.getFlag(ModuleName, "ActiveScene").
     */
    static sceneScrollerSceneFlags = {
        SceneTilerTileIDsArray: [], // an array of Scene Tiler tile ID's active in the scene
        ActiveScene: "" // The scene last viewed by the DM.
    }

    /**
     * A schema of the object to be stored in the LinkedTiles array which is stored in sub-scene flags
     * (see sceneScrollerTilerFlags below)
     * @memberof SceneScroller
     * 
     * NOTE: sceneScrollerTileLinks is just a variable to access the object.  Accessing the object key/value has to be done
     *       directly in the flags.
     *       These flags should be generated by the module used to make the compendium scenes.
     */
    static sceneScrollerTileLinks = {
        SceneUUID: "", // The UUID to the linked compendium scene
        Vector: {},  // ex: {x: 0, y: 0} An object with x & y coordinates in pixels, to the linked tile
        ButtonVector: {} // ex: {x: 0, y: 0} An object with x & y coordinates in pixels, to the desired location of the button
    }

    /**
     * A schema of the flag data transfered from the compendium Scene, which gets stored in sub-scene flags.
     * @memberof SceneScroller
     * 
     * NOTE: sceneScrollerTilerFlags is just a variable to access the object.  Accessing the object key/value has to be done
     *       directly in the flags.  For example: tile.document.getFlag(ModuleName, "LinkedTiles").
     */
    static sceneScrollerTilerFlags = {
        LinkedTiles: [], // An array of the sceneScrollerTileLinks schema (see above).
    }

      /**
     * A schema of the flag data stored in each token, which gets updated continuously as the token moves.
     * @memberof SceneScroller
     * 
     * NOTE: sceneScrollerTokenFlags is just a variable to access the object.  Accessing the object key/value has to be done
     *       directly in the flags.  For example: token.document.getFlag(ModuleName, "CurrentTile").
     */
    static SceneScrollerTokenFlags = {
        CurrentTile: "",  // The ID of the sub-scene the token is currently occupying
        inTileLoc: {},  // ex: {x: 0, y: 0} An object with x & y coordinates in pixels, relative to the top left corner of CurrentTile
    }

    /** A variable to identify when to supress canvas#draw()
     *  See scene_onupdate() in Wrap.js
     *  @param {Boolean}
     */
    static PreventCanvasDraw = false;

    /** A variable to store a token object that needs to be updated after an animation completes
     *  Only for situations where to token moves from one sub-scene to another.
     *  See updateToken() in Wrap.js
     *  @param {Object|Null}    
     */
    static updateToken = null;

    /** The Control Token application
     *  A Form Application window that will allow players and DM's to indirectly/directly select what sub-scene to view.
     */
    static controlToken = null;

    /**
     * A Method to identify if the main Foundry scene is being used as a Scene Scroller viewport.
     * It does this by looking for a flag that is set when Scene Scroller is initialized.
     * @static
     * @param {Scene}       scn         - The scene to query
     * @return {Boolean}                - True if it is a Scene Scroller scene
     * @memberof SceneScroller 
     */
    static isScrollerScene(scn) {
        //log(false, "Executing 'isScrollerScene' method.");
        if (scn?.data?.flags?.hasOwnProperty(ModuleName)) return true;
        return false;
    }

    /** A method activated by a 'ready' hook.  See ss-initialize.js
     *  Also called by initialize().
     *  This method will:
     *    - check to make sure the active scene is a Scene Scroller viewport.  If YES, then
     *    - create alpha maps for every sub-scene (Scene-Tiler tile).
     *    - launch a token selector bar for the DM and any user that can select tokens to control
     *    - display the sub-scene that is stored in the viewport flags.
     *  @return {void}
    */
   static async onReady() {

        log(false, "Executing 'onReady' method.");

        if( !SceneScroller.isScrollerScene(canvas.scene) ) return;

        const subScenes = canvas.scene.getFlag(ModuleName, "SceneTilerTileIDsArray");
        for (const tileId of subScenes) {
            const tile = canvas.background.get(tileId);
            tile._createAlphaMap({keepPixels: true});
        }

        const activeSceneID = canvas.scene.getFlag(ModuleName, "ActiveScene");
        // Display the main sub-scene
        await SceneScroller.displaySubScenes(activeSceneID, true, true);

        if ( game.user.isGM ) {
            SceneScroller.controlToken = new ScrollerViewSubSceneSelector({}, {left: ui.sidebar._element[0].offsetLeft - 205, top: 3}).render(true);
        } else {
            // Look for for all tokens with at least permission level 'viewable'
            // Then check for array length.  If length 1 or greater, launch sub-scene selector window.
        }
   }

    /**
     * A method activated by the GM via a UI button to establish (a hopefully empty scene) as a Scene Scroller Scene.
     *  - The method will initialize the scene as a viewport, and
     *  - The method will launch a form application to prompt the GM to choose an origin scene from a scene compendium.
     *  - Then it will populate the viewport with all the linked sub-scenes for the origin scene.
     *    See ScrollerInitiateScene in Forms.js
     * 
     * @return {void}
     */
    static async initialize() {

        log(false, "Executing 'initialize' method.")
        // Just in case...
        if (!game.user.isGM) return;

        // Open a form application to prompt the GM to select an origin scene from a compendium
        const source = await new Promise((resolve) => {
            new ScrollerInitiateScene(resolve).render(true);
        })

        if (source === null) {
            ui.notifications.error("No seed scene was selected.  Scene initialization failed.");
            log(false, "Scene Scroller Scene initialization failed because a seed scene was not selected.");
            return;
        }

        // Import the compendium scene as a tile
        const isTile = await createTilerTile(source, true, false);
        if ( !isTile ) {
            log(false, "Scene Scroller initialization failed.  Source object passed to createTilerTile():")
            log(false, source);
            ui.notifications.error("Scene Scroller scene initialization failed.")
            return;
        }

        log(true, "Scene [" + canvas.scene.id + "] initialized as a Scene Scroller scene.");

        const myTileId = canvas.scene.getFlag(ModuleName, "ActiveScene");
        const myTile = canvas.background.get(myTileId);

        // Create all the linked sub-scenes of this active sub-scene.
        const linkedSceneIDs = myTile.document.getFlag(ModuleName, "LinkedTiles");
        await this.spawnLinkedTile(linkedSceneIDs)

        Hooks.once('updateScene', async () => {
            // This will position, hide/show all placeables. See onReady().
            await SceneScroller.onReady()
        });
    }

    /**
     * This method will be invoked by initialize and when a sub-scene becomes the active scene.
     * TODO: This method may also be invoked by a trigger (button, condition, etc...) 
     * @param {Object[]|Object}      data      - a UUID or an array of UUID's identifying scene(s) in a compendium.
     * @return {void}
     */
    static async spawnLinkedTile(data) {

        // Just in case...
        if (!game.user.isGM) return;

        log(false, "Executing 'spawnLinkedTile' method.");

        data = data instanceof Array ? data : [data];

        const sourceArray = [];

        for (const obj of data) {
            const source = await fromUuid(obj.SceneUUID);
            if (source === null) {
                log(false, "Linked scene could not be found via the UUID.");
                log(false, sceneUUID);
                return;
            }
            sourceArray.push(source);
        }

        // Import the compendium scene(s) as sub-scene(s).
        const myTile = await createTilerTile(sourceArray);
        if ( !myTile ) {
            log(false, "Spawning linked tile failed.  Source object passed to createTilerTile():");
            log(false, sourceArray);
            ui.notifications.error("Spawning linked compendium scene failed.")
            return;
        }
    }

    /** A method that will offset selected placeables by a vector.
     *  Libwrapper will wrap Scene.prototype._onUpdate to prevent a canvas.draw() when this method is called
     *  to ensure there is no visual disruption.
     *  In some instances, placeables will be moved per client and NOT saved. (called by each client)
     *  In other instances, the placeables will be moved and saved for all clients. (called by DM client only)
     * 
     * @param {Object[]|Object} data                - data object (or array of data objects)
     *                                              - data.placeables = {
     *                                                  drawings: [],
     *                                                  lights: [],
     *                                                  notes: [],
     *                                                  sounds: [],
     *                                                  templates: [],
     *                                                  tiles: [],
     *                                                  tokens: [],
     *                                                  walls: []
     *                                               }
     *                                              - data.vector = {x: <Number>, y: <Number>}
     *                                              - data.placeablesIds = Object of arrays of strings from Scene-Tiler entities flag.
     * 
     * @param {Object}          options             - Options which modify how the clients manipulate the data.
     * @param {boolean}         options.visible     - (Optional), Default, true.  If false, placeables will not be visible.
     * @param {boolean}         options.save        - (Optional), Default, false.  If true, will save translation to database.  Automatically propagated to all clients.
     * @param {boolean}         options.wallHome    - (Optional), Default, false.  If true, the PIXI.Containers will have their position reset to {0,0}.
     */
    static async offsetPlaceables(data, {visible = true, save = false, wallHome = false}={}) {

        log(false, "Executing 'offsetPlaceables' method.");

        data = data instanceof Array ? data : [data];

        // If the data object only has sceneUUID's, this will populate data.placeables with the UUID object.
        tilerTilePlaceables(data);

        const updates = {
            drawings: [],
            lights: [],
            notes: [],
            sounds: [],
            templates: [],
            tiles: [],
            tokens: [],
            walls: []
        };

        for (const subData of data) {

            const vector = subData.vector;
            const placeables = subData.placeables;

            for (const placeableKey in placeables) {
                switch(placeableKey) {
                    case "walls":
                        for (const placeable of placeables[placeableKey]) {
                            const currPosition = placeable.center;
                            const position = wallHome ? {x: 0, y: 0} : {x: currPosition.x + vector.x, y: currPosition.y + vector.y};
                            placeable.position.set(position.x, position.y);
                            placeable.data.c[0] = placeable.data._source.c[0] += vector.x;
                            placeable.data.c[2] = placeable.data._source.c[2] += vector.x;
                            placeable.data.c[1] = placeable.data._source.c[1] += vector.y;
                            placeable.data.c[3] = placeable.data._source.c[3] += vector.y;

                            placeable._onModifyWall(true);
                            
                            updates[placeableKey].push({_id: placeable.id, c: [
                                placeable.data.c[0],
                                placeable.data.c[1],
                                placeable.data.c[2],
                                placeable.data.c[3]
                            ]});
                        }
                        break;
                    default:
                        for (const placeable of placeables[placeableKey]) {
                            placeable.position.set(placeable.data._source.x + vector.x, placeable.data._source.y + vector.y);
                            placeable.data.x = placeable.data._source.x = placeable.data._source.x + vector.x;
                            placeable.data.y = placeable.data._source.y = placeable.data._source.y + vector.y;
                            updates[placeableKey].push({_id: placeable.id, x: placeable.data.x, y: placeable.data.y});
                            switch(placeableKey) {
                                case "lights":
                                    placeable.updateSource({defer: true});
                                    break;
                                case "templates":
                                    await placeable.draw();
                                    break;
                            }
                        }
                }
            }
        }

        // This will toggle the data.placeables to make them visible (true) or hidden (false).
        isVisiblePlaceables(data, visible);

        // This saves the translations to the database.  Should only be used by the DM when the scene dimension change.
        if ( save ) {
            // To keep the visuals smooth, prevent a canvas.draw()
            socketWrapper(msgDict.preventCanvasDrawTrue);
            await canvas.scene.update(updates);
        }
    }

    /** Called by a 'preCreateToken' hook.  See ss-initialize.js
     *  During token creation, this function will determine on what sub-scene the token belongs and update the
     *  token flags with appropriate info.  The token will be saved to the database just inside the padding at
     *  the Top Left Corner (TLC), also known as 'home position'.
     *  A follow up 'tokenCreate' hook will refresh the viewport and 
     *  TODO: position the token where it belongs for each client.
     *  @param {Array}             ...args              - The data passed by the 'preCreateToken' hook.
     *  @return {Boolean}                               - Returning false prevents the token creation from proceeding.
     */
    static tokenCreate(doc, data, options, userId) {

        // This workflow is only for scene-scroller scenes.
        if ( !SceneScroller.isScrollerScene(canvas.scene) ) return true;

        log(false, "Executing 'tokenCreate' methods.");

        const d = canvas.dimensions;
        const tw = doc.data.width * d.size / 2; // Half of Token Width
        const th = doc.data.height * d.size / 2;  // Half of Token Height
        const tc = {  // Token center
            x: data.x + tw,
            y: data.y + th
        }

        // Get a list of all sub-scenes in the viewport
        const subSceneIDs = canvas.scene.getFlag(ModuleName, "SceneTilerTileIDsArray");
        let subSceneArray = [];
        let subScene = {};
        // Check to see if the token drop location is contained in each sub-scene.
        for (const subSceneID of subSceneIDs) {
            subScene = canvas.background.get(subSceneID)
            // Normalize to subScene (Tile) coordinates
            const x = tc.x - subScene.position._x;
            const y = tc.y - subScene.position._y;

            // First test against bounding box
            if ( (x < subScene._alphaMap.minX) || (x > subScene._alphaMap.maxX) ) continue;
            if ( (y < subScene._alphaMap.minY) || (y > subScene._alphaMap.maxY) ) continue;

            subSceneArray.push(subScene);
        }

        // If the token was dropped in the viewport but not in any sub-scene, don't create the token...
        if ( !subSceneArray.length ) {
            log(false, "Aborting token creation.  Not dropped in area defined by a sub-scene (tile).");
            ui.notifications.warn("Token drop location is not contained in any sub-scene.  Token creation aborted.");
            return false;
        }

        // Check the alpha map to see which sub-scene the token was dropped onto.
        let subSceneArrayByPX = [];
        // Only perform this check if there is actually more than one possible sub-scene.
        if ( subSceneArray.length > 1 ) {
            // Test a specific pixel for each sub-scene
            for (const sScene of subSceneArray) {
                const px = (Math.round(y) * Math.round(Math.abs(sScene.data.width))) + Math.round(x);
                const isInSubScene = sScene._alphaMap.pixels[px] === 1;
                if ( isInSubScene ) subSceneArrayByPX.push(subScene);
            }
            
        }

        // If token is dropped inside sub-scene(s), but not on an part of the tile occupied by the map image, don't create the token...
        if ( !subSceneArrayByPX.length && subSceneArray.length > 1 ) {
            log(false, "Aborting token creation.  Token dropped in area of sub-scene (tile) with zero alpha.");
            ui.notifications.warn("Token drop location is not in a valid part of any sub-scene.  Token creation aborted.");
            return false;
        }

        // If testing pixels on the alpha map result in more than one sub-scene, then something went wrong during sub-scene creation
        // or in the logic of this method...  But the method can fail gracefully by assigning it to the first sub-scene in the array
        // which will be a random outcome.
        if ( subSceneArrayByPX.length > 1 ) {
            ui.notifications.warn("Error! Detecting valid drop location for two or more sub-scenes at the same time.  Token created on random sub-scene.");
        }

        const finalSubScene = subSceneArrayByPX[0] || subSceneArray[0];

        // Update the token flags with the required data.
        doc.data.update({
            "flags.scene-scroller.CurrentTile" : finalSubScene.id,
            "flags.scene-scroller.inTileLoc" : {x: data.x - finalSubScene.position._x, y: data.y - finalSubScene.position._y}
        });
        // update data to place the token at the home position
        data.x = d.paddingX;
        data.y = d.paddingY;
        return true;
    }

    /** -This function will activate (position and make visible) the sub-scene entered as a parameter.
     *  -All linked sub-scenes will also be activated.
     *  -All activated sub-scenes will be sorted and placed in the viewport, in their correct positions relative to each other.
     *  -Optionally, all the placeable objects belonging to each activated sub-scene can be activated and positioned in the viewport.
     *  -Tokens that are associated with the activated sub-scene will be activated (visible) and be moved (locally) to their correct
     *   position relative to their associated sub-scene.
     *  NOTE: This method should be called by individual clients.
     * 
     *  @param {String}         tilerTileId             - The tile ID for the 'main' sub-scene.
     *  @param {Boolean}        translatePlaceables     - Optional boolean parameter to indicate if transfering placeables is required.  Defaults to true.
     *  @param {Boolean}        onReady                 - Optional boolean parameter to indicate the viewport is being set up for the first time.  Should only be true in onReady().
     *  @return {Boolean}                               - Return true on success.  Return false if the function fails.
     */
    static async displaySubScenes(tilerTileId, translatePlaceables = true, onReady = false) {

        if ( translatePlaceables ) {
            log(false, "Executing 'displaySubScenes' method.  Translate placeables.");
        } else {
            log(false, "Executing 'displaySubScenes' method.  Do not translate placeables.");
        }

        const viewportActiveScene = canvas.scene.getFlag(ModuleName, "ActiveScene");
        if ( tilerTileId === viewportActiveScene && !onReady) {
            log(false, "Aborting 'displaySubScenes' method because already displaying scene.");
            return;
        }

        // Reset every subscene and placeable to their home position
        await resetMainScene();

        // This is the main sub-scene:
        const mainTile = canvas.background.get(tilerTileId);
        // Get all the linked sub-scenes by the array of ID's saved in main sub-scene flags.  This is an array of UUID's
        const linkedTileUuidArr = mainTile.document.getFlag(ModuleName, 'LinkedTiles').map(l => l.SceneUUID);
        // Get all the sub-scenes in the viewport from scene Flags.  This is an array of tile ID's
        const tilerTilesArr = canvas.scene.getFlag(ModuleName, "SceneTilerTileIDsArray");

        // Build an array for X and an array for Y containing the linked sub-scenes top left corners (TLC) after they are translated
        // by the stored vectors.  The default values are zero, in case the main sub-scene is the left and/or top most tile.
        const arrX = [0];
        const arrY = [0];

        // Iterate for all linkedTiles and add their translated TLC to the arrays.
        for (const tileUuid of linkedTileUuidArr) {
            // Get the tile document for this tileId
            const tile = canvas.background.placeables.filter(t => t.document.getFlag("scene-tiler", "scene") === tileUuid)[0] || false;
            // If it's a 'normal' tile and not a sub-scene
            if ( !tile ) continue;

            // Get the UUID for this tileId
            const Uuid = tile.document.getFlag("scene-tiler", "scene");
            // Skip any tiles that aren't in the viewport's sub-scene array
            // TODO: this shouldn't happen.  Spit out an error if it does?
            if ( !tilerTilesArr.includes(tile.id) ) continue;

            // Get the vector associated with this linked tile
            const vector = mainTile.document.getFlag(ModuleName, 'LinkedTiles')
                                    .filter(id => id.SceneUUID === Uuid)[0]
                                    .Vector;
            // Add linked tile to the map with derived coordinates and UUID (for later)
            arrX.push(-vector.x);
            arrY.push(-vector.y);
        }

        // Find the smallest X and the smallest Y
        const smallestX = Math.min(...arrX);
        const smallestY = Math.min(...arrY);
        
        // The smallest X and smallest Y forms the vector the main sub-scene needs to be translated so that all of the
        // activated sub-scenes to fit in the viewport.  Translate mainTile...
        mainTile.position.set(mainTile.position._x - smallestX, mainTile.position._y - smallestY);
        mainTile.data.x = mainTile.data._source.x -= smallestX;
        mainTile.data.y = mainTile.data._source.y -= smallestY;
        mainTile.visible = true;
        
        // ... and position each linked sub-scene relative to the main sub-scene's new position, using the stored vectors.
        for (const tileUuid of linkedTileUuidArr) {
            // Get the tile document for this tileId
            const tile = canvas.background.placeables.filter(t => t.document.getFlag("scene-tiler", "scene") === tileUuid)[0] || false;
            // TODO: this shouldn't happen.  Spit out an error if it does?
            if ( !tile ) continue;

            // Skip any tiles that aren't in the viewport's sub-scene array
            // TODO: this shouldn't happen.  Spit out an error if it does?
            if ( !tilerTilesArr.includes(tile.id) ) continue;

            // Get the UUID for this tileId
            const Uuid = tile.document.getFlag("scene-tiler", "scene");

            // Get the vector associated with this linked tile
            const vector = mainTile.document.getFlag(ModuleName, 'LinkedTiles')
                                    .filter(id => id.SceneUUID === Uuid)[0]
                                    .Vector;
            
            tile.position.set(mainTile.data.x - vector.x, mainTile.data.y - vector.y);
            tile.data.x = tile.data._source.x = mainTile.data.x - vector.x;
            tile.data.y = tile.data._source.y = mainTile.data.y - vector.y;
            tile.visible = true;
        }

        // For each token associated with any particular active sub-scene, move the token to the position (relative to tile TLC) saved in the token flags.
        const allTokensArr = canvas.tokens.placeables;
        const tokenArr = [];
        for (const token of allTokensArr) {
            const tokenTileId = token.document.getFlag(ModuleName, "CurrentTile");
            const tile = canvas.background.get(tokenTileId);
            if ( tile.visible === true ) tokenArr.push(token);
        }

        moveTokensLocal(tokenArr);

        // Update flags to indicate this is now the ActiveScene
        await canvas.scene.setFlag(ModuleName, "ActiveScene", tilerTileId);

        // If required, move all the placeable objects associated with this sub-scene (see Scene-Tiler flags) by the same translation.
        if ( !translatePlaceables ) return;
        const offsetPlaceablesObjArray = [];
        for (const tileId of tilerTilesArr) {
            const tile = canvas.background.get(tileId);
            if ( tile.visible === false ) continue; 
            const d = canvas.dimensions;
            const placeablesIds = tile.document.getFlag("scene-tiler", "entities");
            const offsetObj = {
                vector: {x: tile.position._x - d.paddingX, y: tile.position._y - d.paddingY},
                placeablesIds: placeablesIds,
                placeables: null
            }
            offsetPlaceablesObjArray.push(offsetObj);
        }

        await SceneScroller.offsetPlaceables(offsetPlaceablesObjArray, {visible: true});
    }
}